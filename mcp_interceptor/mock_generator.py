#!/usr/bin/env python3
"""
Mock MCP Server Generator

Reads trace files and generates fully functional mock MCP servers that
replay recorded responses without needing the original server.
"""

import sys
from pathlib import Path

# Add parent directory to path for standalone execution
sys.path.insert(0, str(Path(__file__).parent.parent))

from typing import Dict, List, Any, Optional
import json
from mcp_interceptor.trace_format import TraceReader, MCPSession, MCPCallPair


class MockServerGenerator:
    """Generates mock MCP server code from trace files"""

    def __init__(self, trace_file: str):
        self.reader = TraceReader(trace_file)
        self.sessions = self.reader.read_sessions()

    def analyze_sessions(self) -> Dict[str, Any]:
        """Analyze sessions to extract patterns and metadata"""
        all_methods = set()
        method_calls = {}  # method -> list of (args, kwargs, result)

        for session in self.sessions:
            for call in session.calls:
                method = call.request.method
                all_methods.add(method)

                if method not in method_calls:
                    method_calls[method] = []

                # Store successful calls only
                if call.response.success:
                    method_calls[method].append({
                        'args': call.request.args,
                        'kwargs': call.request.kwargs,
                        'result': call.response.result
                    })

        return {
            'methods': sorted(all_methods),
            'method_calls': method_calls,
            'server_info': self.sessions[0].server_info if self.sessions else {},
            'total_sessions': len(self.sessions)
        }

    def generate_mock_server(self, output_file: str, server_name: str = "MockMCPServer"):
        """Generate a complete mock MCP server Python file"""
        analysis = self.analyze_sessions()

        code = self._generate_header(server_name)
        code += self._generate_response_data(analysis['method_calls'])
        code += self._generate_server_class(server_name, analysis)
        code += self._generate_main(server_name, analysis['server_info'])

        with open(output_file, 'w') as f:
            f.write(code)

        print(f"✓ Generated mock server: {output_file}")
        print(f"  - Methods: {', '.join(analysis['methods'])}")
        print(f"  - Total sessions analyzed: {analysis['total_sessions']}")

    def _generate_header(self, server_name: str) -> str:
        """Generate file header and imports"""
        return f'''#!/usr/bin/env python3
"""
Mock MCP Server: {server_name}

Auto-generated from MCP trace recordings.
This server replays recorded responses without requiring the original backend.

Generated by: mock_generator.py
"""

import asyncio
from typing import Any, Dict, List, Optional
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import (
    Tool, TextContent, ImageContent, EmbeddedResource,
    CallToolResult, ListToolsResult
)
import json


'''

    def _generate_response_data(self, method_calls: Dict[str, List[Dict]]) -> str:
        """Generate the static response data structure"""
        import pprint

        code = "# Recorded responses from trace\n"
        code += "MOCK_RESPONSES = {\n"

        for method, calls in method_calls.items():
            code += f"    '{method}': [\n"
            for call in calls:
                # Store the full call pattern for matching
                code += "        {\n"
                code += f"            'args': {repr(call['args'])},\n"
                code += f"            'kwargs': {repr(call['kwargs'])},\n"
                # Use repr for Python-compatible output (None, True, False instead of null, true, false)
                result_repr = pprint.pformat(call['result'], width=120, compact=False)
                # Indent the result properly
                indented_result = '\n'.join('            ' + line for line in result_repr.split('\n'))
                code += f"            'result': {indented_result}\n"
                code += "        },\n"
            code += "    ],\n"

        code += "}\n\n"
        return code

    def _generate_server_class(self, server_name: str, analysis: Dict) -> str:
        """Generate the mock server class with all methods"""
        methods = analysis['methods']

        code = f"class {server_name}:\n"
        code += '    """Mock MCP server that replays recorded responses"""\n\n'
        code += "    def __init__(self):\n"
        code += "        self.server = Server(name='mock-server')\n"
        code += "        self._setup_handlers()\n\n"

        # Setup handlers method
        code += "    def _setup_handlers(self):\n"
        code += '        """Register all MCP method handlers"""\n'

        if 'list_tools' in methods:
            code += "        @self.server.list_tools()\n"
            code += "        async def list_tools() -> ListToolsResult:\n"
            code += "            return await self.handle_list_tools()\n\n"

        if 'call_tool' in methods:
            code += "        @self.server.call_tool()\n"
            code += "        async def call_tool(name: str, arguments: dict) -> CallToolResult:\n"
            code += "            return await self.handle_call_tool(name, arguments)\n\n"

        # Generate handler methods
        if 'initialize' in methods:
            code += self._generate_initialize_handler()

        if 'list_tools' in methods:
            code += self._generate_list_tools_handler(analysis)

        if 'call_tool' in methods:
            code += self._generate_call_tool_handler()

        if 'list_resources' in methods:
            code += self._generate_list_resources_handler()

        if 'read_resource' in methods:
            code += self._generate_read_resource_handler()

        # Add generic response matcher
        code += self._generate_response_matcher()

        # Add run method
        code += "    async def run(self):\n"
        code += '        """Run the mock server"""\n'
        code += "        async with stdio_server() as (read_stream, write_stream):\n"
        code += "            await self.server.run(\n"
        code += "                read_stream,\n"
        code += "                write_stream,\n"
        code += "                self.server.create_initialization_options()\n"
        code += "            )\n\n"

        return code

    def _generate_initialize_handler(self) -> str:
        """Generate initialize method handler"""
        return """    async def handle_initialize(self):
        \"\"\"Handle initialize request\"\"\"
        result = self._find_matching_response('initialize', [], {})
        return result if result else {
            "protocolVersion": "2024-11-05",
            "capabilities": {},
            "serverInfo": {"name": "mock-server", "version": "1.0.0"}
        }

"""

    def _generate_list_tools_handler(self, analysis: Dict) -> str:
        """Generate list_tools handler"""
        return """    async def handle_list_tools(self) -> ListToolsResult:
        \"\"\"Handle list_tools request - returns recorded tools\"\"\"
        result = self._find_matching_response('list_tools', [], {})
        if result and '_type' in result and result['_type'] == 'ListToolsResult':
            # Convert dict back to ListToolsResult
            tools = []
            for tool_data in result.get('tools', []):
                tools.append(Tool(
                    name=tool_data['name'],
                    description=tool_data.get('description', ''),
                    inputSchema=tool_data.get('inputSchema', {})
                ))
            return ListToolsResult(tools=tools)
        return ListToolsResult(tools=[])

"""

    def _generate_call_tool_handler(self) -> str:
        """Generate call_tool handler"""
        return """    async def handle_call_tool(self, name: str, arguments: dict) -> CallToolResult:
        \"\"\"Handle call_tool request - returns recorded response\"\"\"
        # call_tool is recorded with args=[name, arguments], so match that way
        result = self._find_matching_response('call_tool', [name, arguments], {})

        if result:
            # Extract content from recorded result
            content_data = result.get('content', [])
            content = []

            for item in content_data:
                if item.get('type') == 'text':
                    content.append(TextContent(
                        type='text',
                        text=item.get('text', '')
                    ))

            # Use the recorded isError value
            is_error = result.get('isError', False)
            return CallToolResult(content=content, isError=is_error)

        # Fallback if no match found
        return CallToolResult(
            content=[TextContent(type='text', text=f'No recorded response for tool: {name}')],
            isError=True
        )

"""

    def _generate_list_resources_handler(self) -> str:
        """Generate list_resources handler"""
        return """    async def handle_list_resources(self):
        \"\"\"Handle list_resources request\"\"\"
        result = self._find_matching_response('list_resources', [], {})
        return result if result else {"resources": []}

"""

    def _generate_read_resource_handler(self) -> str:
        """Generate read_resource handler"""
        return """    async def handle_read_resource(self, uri: str):
        \"\"\"Handle read_resource request\"\"\"
        result = self._find_matching_response('read_resource', [uri], {})
        return result if result else {"contents": []}

"""

    def _generate_response_matcher(self) -> str:
        """Generate the response matching logic"""
        return """    def _find_matching_response(self, method: str, args: list, kwargs: dict) -> Optional[Any]:
        \"\"\"Find a matching recorded response for the given call\"\"\"
        if method not in MOCK_RESPONSES:
            return None

        # For call_tool, do special matching
        if method == 'call_tool' and len(args) == 2:
            tool_name, tool_args = args
            for recorded in MOCK_RESPONSES[method]:
                if (len(recorded['args']) == 2 and
                    recorded['args'][0] == tool_name):
                    # Match found based on tool name
                    # Could add argument matching here if needed
                    return recorded['result']

        # Try exact match
        for recorded in MOCK_RESPONSES[method]:
            if self._args_match(recorded['args'], args) and self._kwargs_match(recorded['kwargs'], kwargs):
                return recorded['result']

        # Fallback: return first response for this method
        if MOCK_RESPONSES[method]:
            return MOCK_RESPONSES[method][0]['result']

        return None

    def _args_match(self, recorded_args: list, actual_args: list) -> bool:
        \"\"\"Check if args match\"\"\"
        return recorded_args == actual_args

    def _kwargs_match(self, recorded_kwargs: dict, actual_kwargs: dict) -> bool:
        \"\"\"Check if kwargs match (with some flexibility)\"\"\"
        return recorded_kwargs == actual_kwargs

"""

    def _generate_main(self, server_name: str, server_info: Dict) -> str:
        """Generate main execution block"""
        return f'''
if __name__ == "__main__":
    # Server info from trace: {json.dumps(server_info)}
    server = {server_name}()
    asyncio.run(server.run())
'''


def main():
    """CLI interface for mock server generation"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Generate mock MCP server from trace file"
    )
    parser.add_argument(
        'trace_file',
        help='Path to trace file (NDJSON format with MCPSession objects)'
    )
    parser.add_argument(
        '-o', '--output',
        default='mock_server.py',
        help='Output file for generated mock server (default: mock_server.py)'
    )
    parser.add_argument(
        '-n', '--name',
        default='MockMCPServer',
        help='Name for the generated server class (default: MockMCPServer)'
    )

    args = parser.parse_args()

    # Validate input
    if not Path(args.trace_file).exists():
        print(f"Error: Trace file not found: {args.trace_file}")
        return 1

    # Generate mock server
    try:
        generator = MockServerGenerator(args.trace_file)
        generator.generate_mock_server(args.output, args.name)
        print(f"\n✓ Success! Run the mock server with:")
        print(f"  python {args.output}")
        return 0
    except Exception as e:
        print(f"Error generating mock server: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    exit(main())
